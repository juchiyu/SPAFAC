% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/sSTATIS.R
\name{sparseSTATIS}
\alias{sparseSTATIS}
\title{Sparse STATIS}
\source{
Some lines of the function are inspired by the MExPosition package by Derek Beaton and Cherise Chin Fatt.
}
\usage{
sparseSTATIS(
  X,
  column.design,
  mfa.normalize = TRUE,
  sparse.Cmat = FALSE,
  sparse.grandX = TRUE,
  components.Cmat = 0,
  components.grandX = 0,
  sparseOption = "variable",
  center = TRUE,
  scale = TRUE,
  tol = .Machine$double.eps,
  init.Cmat = "eig",
  init.grandX = "svd",
  initLeft.grandX = NULL,
  initRight.grandX = NULL,
  seed = NULL,
  rdsLeft.Cmat = rep(1, components.Cmat),
  rdsRight.Cmat = rep(1, components.Cmat),
  rdsLeft.grandX = rep(1, components.grandX),
  rdsRight.grandX = rep(1, components.grandX),
  grp.Cmat = NULL,
  grpLeft.grandX = NULL,
  grpRight.grandX = NULL,
  orthogonality.Cmat = "loadings",
  OrthSpaceLeft.Cmat = NULL,
  OrthSpaceRight.Cmat = NULL,
  orthogonality.grandX = "loadings",
  OrthSpaceLeft.grandX = NULL,
  OrthSpaceRight.grandX = NULL,
  projPriority.Cmat = "orth",
  projPriorityLeft.Cmat = projPriority.Cmat,
  projPriorityRight.Cmat = projPriority.Cmat,
  projPriority.grandX = "orth",
  projPriorityLeft.grandX = projPriority.grandX,
  projPriorityRight.Slus = projPriority.grandX,
  itermaxALS.Cmat = 1000,
  itermaxPOCS.Cmat = 1000,
  itermaxALS.grandX = 1000,
  itermaxPOCS.grandX = 1000,
  epsALS.Cmat = 1e-10,
  epsPOCS.Cmat = 1e-10,
  epsALS.grandX = 1e-10,
  epsPOCS.grandX = 1e-10
)
}
\arguments{
\item{X}{Data matrix with I rows and J columns.}

\item{column.design}{Design vector indicating the grouping of columns.}

\item{mfa.normalize}{Logical indicating whether to normalize data for MFA; defaults to TRUE.}

\item{sparse.Cmat}{Logical indicating whether the C matrix (RV matrix) is sparsified; defaults to FALSE.}

\item{sparse.grandX}{Logical indicating whether the compromise is sparsified; defaults to TRUE.}

\item{components.Cmat}{Number of dimensions to extract from the C matrix (RV matrix); defaults to 0.}

\item{components.grandX}{Number of dimensions to extract from the compromise; defaults to 0.}

\item{sparseOption}{"variable" or "subtable" indicating the sparsity option.}

\item{center}{Logical or numeric vector for centering each column of X; passed to \code{\link{scale}}.}

\item{scale}{Logical or numeric vector for scaling each column of X; passed to \code{\link{scale}}.}

\item{tol}{Tolerance for the convergence criterion; defaults to \code{.Machine$double.eps}.}

\item{init.Cmat}{Initialization method for Cmat; defaults to "eig".}

\item{init.grandX}{Initialization method for grandX; defaults to "svd".}

\item{initLeft.grandX}{Initial values for the left side of grandX; defaults to NULL.}

\item{initRight.grandX}{Initial values for the right side of grandX; defaults to NULL.}

\item{seed}{Seed for random number generation; defaults to NULL.}

\item{rdsLeft.Cmat}{Radii for the left side of Cmat; defaults to rep(1, components.Cmat).}

\item{rdsRight.Cmat}{Radii for the right side of Cmat; defaults to rep(1, components.Cmat).}

\item{rdsLeft.grandX}{Radii for the left side of grandX; defaults to rep(1, components.grandX).}

\item{rdsRight.grandX}{Radii for the right side of grandX; defaults to rep(1, components.grandX).}

\item{grp.Cmat}{Grouping vector for the Cmat; defaults to NULL.}

\item{grpLeft.grandX}{Grouping vector for the left side of grandX; defaults to NULL.}

\item{grpRight.grandX}{Grouping vector for the right side of grandX; defaults to NULL.}

\item{orthogonality.Cmat}{Type of orthogonality constraint for Cmat; defaults to "loadings".}

\item{OrthSpaceLeft.Cmat}{Orthogonal space for the left side of Cmat; defaults to NULL.}

\item{OrthSpaceRight.Cmat}{Orthogonal space for the right side of Cmat; defaults to NULL.}

\item{orthogonality.grandX}{Type of orthogonality constraint for grandX; defaults to "loadings".}

\item{OrthSpaceLeft.grandX}{Orthogonal space for the left side of grandX; defaults to NULL.}

\item{OrthSpaceRight.grandX}{Orthogonal space for the right side of grandX; defaults to NULL.}

\item{projPriority.Cmat}{Priority of the projection for Cmat; defaults to "orth".}

\item{projPriorityLeft.Cmat}{Priority of the left projection for Cmat; defaults to projPriority.Cmat.}

\item{projPriorityRight.Cmat}{Priority of the right projection for Cmat; defaults to projPriority.Cmat.}

\item{projPriority.grandX}{Priority of the projection for grandX; defaults to "orth".}

\item{projPriorityLeft.grandX}{Priority of the left projection for grandX; defaults to projPriority.grandX.}

\item{projPriorityRight.Slus}{Priority of the right projection for grandX; defaults to projPriority.grandX.}

\item{itermaxALS.Cmat}{Maximum number of ALS iterations for Cmat; defaults to 1000.}

\item{itermaxPOCS.Cmat}{Maximum number of POCS iterations for Cmat; defaults to 1000.}

\item{itermaxALS.grandX}{Maximum number of ALS iterations for grandX; defaults to 1000.}

\item{itermaxPOCS.grandX}{Maximum number of POCS iterations for grandX; defaults to 1000.}

\item{epsALS.Cmat}{Convergence criterion for ALS for Cmat; defaults to 1e-10.}

\item{epsPOCS.Cmat}{Convergence criterion for POCS for Cmat; defaults to 1e-10.}

\item{epsALS.grandX}{Convergence criterion for ALS for grandX; defaults to 1e-10.}

\item{epsPOCS.grandX}{Convergence criterion for POCS for grandX; defaults to 1e-10.}
}
\value{
Returns an object containing the results of the sparse STATIS analysis, including details of the C matrix (RV matrix), compromise, and various parameters and settings used in the analysis.
}
\description{
Performs sparse STATIS analysis on a data matrix with a specific column design.
}
\examples{
# Example usage of sparseSTATIS function
# Assuming `X` is a data matrix and `column.design` is the design vector
\dontrun{result <- sparseSTATIS(X = X, column.design = column.design)}

}
